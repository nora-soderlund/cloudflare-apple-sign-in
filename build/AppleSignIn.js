import createJwksClient from "@nora-soderlund/jwks-rsa";
import jwt from "@tsndr/cloudflare-worker-jwt";
export class AppleSignIn {
    constructor(options) {
        if (!options?.clientId)
            throw new Error("clientId is empty");
        if (!options?.teamId)
            throw new Error("teamId is empty");
        if (!options?.keyIdentifier)
            throw new Error("keyIdentifier is empty");
        this.clientId = options.clientId;
        this.teamId = options.teamId;
        this.keyIdentifier = options.keyIdentifier;
        let privateKey;
        if (Object.prototype.hasOwnProperty.call(options, "privateKey")) {
            privateKey = options.privateKey;
        }
        if (!privateKey) {
            throw new Error("Empty private key from given input method");
        }
        this.privateKey = privateKey;
        /**
         * Create jwks instance that caches 5 kid's up to 10 minutes to reduce amount calls to apple auth keys endpoint.
         * @link https://github.com/auth0/node-jwks-rsa#caching
         */
        this.jwksClient = createJwksClient({
            jwksUri: "https://appleid.apple.com/auth/keys",
        });
    }
    /**
     * Function that generates a url that can be used to redirect the user and begin the "Sign in with Apple" flow.
     * @link https://developer.apple.com/documentation/sign_in_with_apple/sign_in_with_apple_js/incorporating_sign_in_with_apple_into_other_platforms#3332113
     */
    getAuthorizationUrl(options) {
        if (!options.redirectUri)
            throw new Error("redirectUri is empty");
        if (options.scope && !Array.isArray(options.scope))
            throw new Error("scope must be an array");
        const url = new URL("https://appleid.apple.com/auth/authorize");
        url.searchParams.append("client_id", this.clientId);
        url.searchParams.append("redirect_uri", options.redirectUri);
        url.searchParams.append("response_type", "code");
        if (options.scope && options.scope.length) {
            url.searchParams.append("scope", options.scope.join(" "));
            /**
             * If you requested any scopes, an additional `response_mode=form_post` parameter must be set.
             * Docs: https://developer.apple.com/documentation/sign_in_with_apple/sign_in_with_apple_js/incorporating_sign_in_with_apple_into_other_platforms#3332113
             */
            // TODO: maybe add other response_mode parameters support - "query", "fragment" and "form_post"
            url.searchParams.append("response_mode", "form_post");
        }
        if (options.state) {
            url.searchParams.append("state", options.state);
        }
        if (options.nonce) {
            url.searchParams.append("nonce", options.nonce);
        }
        return url.toString();
    }
    async getAuthorizationToken(
    /**
     * A secret generated as a JSON Web Token that uses the secret key generated by the WWDR portal.
     */
    clientSecret, 
    /**
     * A single-use authorization code that is valid for five minutes from generation.
     */
    code, options) {
        if (!clientSecret)
            throw new Error("clientSecret is empty");
        if (!code)
            throw new Error("code is empty");
        const response = await fetch("https://appleid.apple.com/auth/token", {
            method: "POST",
            body: Object.entries({
                client_id: this.clientId,
                client_secret: clientSecret,
                grant_type: "authorization_code",
                code,
                redirect_uri: options?.redirectUri,
            }).map(([key, value]) => [key, encodeURIComponent(value ?? "")].join('=')).join('&')
        });
        if (!response.ok) {
            const statusCode = response?.status;
            const text = await response.text();
            throw new Error(`Authorization request failed with reason "${text}" and status code "${statusCode}"`);
        }
        return await response.json();
    }
    async refreshAuthorizationToken(
    /**
     * A secret generated as a JSON Web Token that uses the secret key generated by the WWDR portal.
     */
    clientSecret, 
    /**
     * The refresh token received during the authorization request.
     */
    refreshToken) {
        if (!clientSecret)
            throw new Error("clientSecret is empty");
        if (!refreshToken)
            throw new Error("refreshToken is empty");
        const response = await fetch("https://appleid.apple.com/auth/token", {
            method: "POST",
            body: Object.entries({
                client_id: this.clientId,
                client_secret: clientSecret,
                grant_type: "refresh_token",
                refresh_token: refreshToken,
            }).map(([key, value]) => [key, encodeURIComponent(value ?? "")].join('=')).join('&'),
        });
        if (!response.ok) {
            const statusCode = response?.status;
            const text = await response.text();
            throw new Error(`Authorization request failed with reason "${text}" and status code "${statusCode}"`);
        }
        return response.json();
    }
    async createClientSecret(options) {
        /**
         * As per apple docs the max duration a client secret claim can last - 6 months in secods
         */
        const MAX_CLAIM_DURATION_SECONDS = 15777000;
        const claimDurationSeconds = options?.expirationDuration || MAX_CLAIM_DURATION_SECONDS;
        if (claimDurationSeconds > MAX_CLAIM_DURATION_SECONDS) {
            throw new Error("Claim duration can\t exceed 6 months");
        }
        const timeNowSeconds = Math.floor(Date.now() / 1000);
        const claims = {
            iss: this.teamId,
            iat: timeNowSeconds,
            exp: timeNowSeconds + claimDurationSeconds,
            aud: "https://appleid.apple.com",
            sub: this.clientId,
        };
        return await jwt.sign(claims, this.privateKey, {
            algorithm: "ES256",
            header: {
                alg: "ES256",
                kid: this.keyIdentifier
            }
        });
    }
    getAppleSigningKey(kid) {
        return new Promise((resolve, reject) => {
            this.jwksClient.getSigningKey(kid, (err, key) => {
                if (err || key === undefined) {
                    reject(err);
                }
                else {
                    resolve(key);
                }
            });
        });
    }
    /**
     * Verify identity of a give JsonWebToken string.
     */
    async verifyIdToken(idToken, options) {
        if (!idToken)
            throw new Error("idToken is empty");
        /**
         * Decode the jwt into header and payload so we can find it's appropriate apple public key
         * https://github.com/auth0/node-jsonwebtoken/blob/master/decode.js#L22-L27
         */
        const decodedIdToken = jwt.decode(idToken);
        // We expect that it returns an object, if we get anything else then throw error
        if (!(decodedIdToken !== null && typeof decodedIdToken === "object")) {
            throw new Error("Unexpected results from decoded idToken");
        }
        const kid = decodedIdToken?.header?.kid;
        const alg = decodedIdToken?.header?.alg;
        if (!kid)
            throw new Error("Missing kid in given idToken");
        if (!alg)
            throw new Error("Missing alg in given idToken");
        // Will throw if no key found
        const key = await this.getAppleSigningKey(kid);
        // Offload all jwt verification to do the heavy job, we just make sure to pass in needed options
        const jwtClaims = await jwt.verify(idToken, key.getPublicKey(), {
            algorithm: alg
        });
        if (jwtClaims && decodedIdToken.payload
        /*&& decodedIdToken.payload?.iss === "https://appleid.apple.com"
        && decodedIdToken.payload.aud === this.clientId
        && decodedIdToken.header?.alg === alg
        && decodedIdToken.payload.sub === options.subject*/ ) {
            return decodedIdToken.payload;
        }
        throw new Error("Validation failed.");
        /*, {
          issuer: "https://appleid.apple.com",
          audience: this.clientId,
          algorithms: [alg],
          nonce: options?.nonce,
          ignoreExpiration: options?.ignoreExpiration,
          subject: options?.subject,
        })*/ // as AppleIdTokenType;
        // TODO: possibly implementation of this, as currently the last character is missmatching
        // https://sarunw.com/posts/sign-in-with-apple-4/#authorization-code-(code)-validation
        // if (options?.authorizationCode) {
        //   const hashedCode = crypto.createHash("sha256").update(options.authorizationCode).digest("base64");
        //   const firstHalfOfhashedCode = hashedCode.slice(0, (hashedCode.length - 1) / 2);
        //   if (jwtClaims.c_hash !== firstHalfOfhashedCode) {
        //     throw new Error("Missmatching authorziationCode and c_hash claim");
        //   }
        // }
        //return jwtClaims;
    }
}
export default AppleSignIn;
//# sourceMappingURL=AppleSignIn.js.map